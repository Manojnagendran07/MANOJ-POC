 
trigger:
  branches:
    include:
      - main      # Prod environment
      - test      # Test environment
      - dev       # Dev environment
pool:
  vmImage: 'windows-latest'  # Use the default Microsoft-hosted Windows agent
steps:
  # Step 0: Install pbicli globally using npm
  - script: |
      npm install -g @powerbi-cli/powerbi-cli
    displayName: 'Install pbicli'
  # Step 1: Checkout the repository and fetch Git LFS files
  - checkout: self
    lfs: true  # This ensures that Git LFS files are fetched
  # Step 2: Authenticate with Power BI
  - powershell: |
      pbicli login --service-principal --principal ${env:CLIENT_ID} --secret ${env:CLIENT_SECRET} --tenant ${env:TENANT_ID}
    displayName: 'Authenticate with Power BI'
    env:
      CLIENT_ID: $(CLIENT_ID)
      CLIENT_SECRET: $(CLIENT_SECRET)
      TENANT_ID: $(TENANT_ID)
  # Step 3: Determine the workspace ID based on the branch
  - powershell: |
      # Get the current branch name
      $branchName = "$(Build.SourceBranchName)"
      # Set the workspace ID based on the branch
      if ($branchName -eq "main") {
        $workspaceId = "$(prodWorkspaceId)"
      } elseif ($branchName -eq "test") {
        $workspaceId = "$(testWorkspaceId)"
      } elseif ($branchName -eq "dev") {
        $workspaceId = "$(devWorkspaceId)"
      } else {
        Write-Host "##[error]Unsupported branch: $branchName"
        exit 1
      }
      # Output the workspace ID for subsequent steps
      Write-Host "##vso[task.setvariable variable=workspaceId]$workspaceId"
      Write-Host "##[info]Selected workspace ID for branch '$branchName': $workspaceId"
    displayName: 'Determine Workspace ID Based on Branch'
  # Step 4: Find all .pbix files in the repository
  - powershell: |
      # Use PowerShell to find all .pbix files recursively
      $pbixFiles = Get-ChildItem -Path . -Recurse -Filter *.pbix | Select-Object -ExpandProperty FullName
      echo "##[section]Found PBIX Files:"
      if ($pbixFiles.Count -eq 0) {
        echo "No PBIX files found in the repository."
      } else {
        $pbixFiles | ForEach-Object { echo $_ }
      }
      # Set the output variable for subsequent steps
      Write-Host "##vso[task.setvariable variable=pbixFiles]$($pbixFiles -join ';')"
    displayName: 'List all the PBIX Files in the current directory'
  # Step 5: Rename .pbix files with the naming convention: reponame-reportname.pbix
  - powershell: |
      # Retrieve the repository name
      $repoName = "$(Build.Repository.Name)"
      # Retrieve the list of PBIX files from the previous step
      $pbixFiles = "$(pbixFiles)"
      if (-not $pbixFiles) {
        echo "##[warning]No PBIX files found in the repository. Skipping rename step."
        exit 0
      }
      # Split the semicolon-separated list into an array
      $pbixFilesArray = $pbixFiles -split ';'
      # Create a new list for renamed files
      $renamedFiles = @()
      # Loop through each PBIX file and rename it
      foreach ($file in $pbixFilesArray) {
        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($file)
        $newFileName = "$repoName-$fileName.pbix"
        $newFilePath = Join-Path ([System.IO.Path]::GetDirectoryName($file)) $newFileName
        # Rename the file
        Rename-Item -Path $file -NewName $newFileName
        echo "##[info]Renamed file: $file -> $newFilePath"
        # Add the new file path to the list
        $renamedFiles += $newFilePath
      }
      # Set the output variable for subsequent steps
      Write-Host "##vso[task.setvariable variable=pbixFiles]$($renamedFiles -join ';')"
    displayName: 'Rename PBIX Files'
  # Step 6: Get the list of reports and datasets in the Power BI workspace
  - powershell: |
      # Retrieve the workspace ID from the previous step
      $workspaceId = "$(workspaceId)"
      # Retrieve the list of reports in the workspace
      $reportsJson = pbicli report list --workspace $workspaceId --output json
      $reports = ($reportsJson | ConvertFrom-Json) | Select-Object -ExpandProperty name
      echo "##[section]Reports in Workspace:"
      if ($reports.Count -eq 0) {
        echo "No reports found in the workspace."
      } else {
        $reports | ForEach-Object { echo $_ }
      }
      # Retrieve the list of datasets in the workspace
      $datasetsJson = pbicli dataset list --workspace $workspaceId --output json
      $datasets = ($datasetsJson | ConvertFrom-Json) | Select-Object -ExpandProperty name
      echo "##[section]Datasets in Workspace:"
      if ($datasets.Count -eq 0) {
        echo "No datasets found in the workspace."
      } else {
        $datasets | ForEach-Object { echo $_ }
      }
      # Set the output variables for subsequent steps
      Write-Host "##vso[task.setvariable variable=reports]$($reports -join ';')"
      Write-Host "##vso[task.setvariable variable=datasets]$($datasets -join ';')"
    displayName: 'Get Reports and Datasets in Power BI Workspace'
  # Step 7: Publish all renamed .pbix files to the workspace
  - powershell: |
      # Retrieve the list of renamed PBIX files from the previous step
      $pbixFiles = "$(pbixFiles)"
      if (-not $pbixFiles) {
        echo "##[warning]No PBIX files found in the repository. Skipping publish step."
        exit 0
      }
      # Split the semicolon-separated list into an array
      $pbixFilesArray = $pbixFiles -split ';'
      # Retrieve the workspace ID from the previous step
      $workspaceId = "$(workspaceId)"
      # Loop through each PBIX file and publish it to the workspace
      foreach ($file in $pbixFilesArray) {
        echo "##[section]Publishing PBIX File: $file"
        pbicli import pbix -w $workspaceId --file "$file" --conflict CreateOrOverwrite
        echo "##[info]Successfully published: $file"
      }
    displayName: 'Publish PBIX Files to Power BI Workspace'
  # Step 8: Delete reports and datasets in the workspace that are no longer in the repository
  - powershell: |
      # Retrieve the list of PBIX files, reports, and datasets from previous steps
      $pbixFiles = "$(pbixFiles)"
      $reports = "$(reports)"
      $datasets = "$(datasets)"
      # Split the semicolon-separated lists into arrays
      $pbixFilesArray = if ($pbixFiles) { $pbixFiles -split ';' } else { @() }
      $reportsArray = if ($reports) { $reports -split ';' } else { @() }
      $datasetsArray = if ($datasets) { $datasets -split ';' } else { @() }
      # Retrieve the workspace ID from the previous step
      $workspaceId = "$(workspaceId)"
      # Retrieve the repository name
      $repoName = "$(Build.Repository.Name)"
      # Compute the repository name prefix (e.g., "PowerBI1-")
      $repoNamePrefix = "$([System.IO.Path]::GetFileNameWithoutExtension($repoName))-"
      # Get the base names of the PBIX files (including the repository prefix)
      $pbixFileNames = $pbixFilesArray | ForEach-Object {
          [System.IO.Path]::GetFileNameWithoutExtension($_)
      }
      # Debug: Output the PBIX file names
      Write-Host "##[info]PBIX File Names (with repo prefix): $($pbixFileNames -join ', ')"
      # Filter reports and datasets to include only those belonging to the current repository
      $filteredReports = $reportsArray | Where-Object { $_.StartsWith($repoNamePrefix) }
      $filteredDatasets = $datasetsArray | Where-Object { $_.StartsWith($repoNamePrefix) }
      # Debug: Output the filtered reports and datasets
      Write-Host "##[info]Filtered Reports: $($filteredReports -join ', ')"
      Write-Host "##[info]Filtered Datasets: $($filteredDatasets -join ', ')"
      # Identify and delete orphaned reports
      Write-Host "##[section]Checking for Orphaned Reports..."
      foreach ($report in $filteredReports) {
          $matchingFile = $pbixFileNames | Where-Object { $_ -eq $report }
          if (-not $matchingFile) {
              Write-Host "##[info]Deleting orphaned report: $report"
              if ($report) {
                  pbicli report delete --workspace $workspaceId --report $report
                  Write-Host "##[info]Deleted report: $report"
              } else {
                  Write-Host "##[error]Report name is empty. Skipping deletion."
              }
          }
      }
      # Identify and delete orphaned datasets
      Write-Host "##[section]Checking for Orphaned Datasets..."
      foreach ($dataset in $filteredDatasets) {
          $matchingFile = $pbixFileNames | Where-Object { $_ -eq $dataset }
          if (-not $matchingFile) {
              Write-Host "##[info]Deleting orphaned dataset: $dataset"
              if ($dataset) {
                  pbicli dataset delete --workspace $workspaceId --dataset $dataset
                  Write-Host "##[info]Deleted dataset: $dataset"
              } else {
                  Write-Host "##[error]Dataset name is empty. Skipping deletion."
              }
          }
      }
    displayName: 'Identify and Delete Orphaned Reports and Datasets'
  # Step 9: Rebind Reports to Datasets Based on federated-model.txt
  - powershell: |
      # Check if federated-model.txt exists in the root folder
      $federatedModelFile = ".\federated-model.txt"
      if (-not (Test-Path $federatedModelFile)) {
        Write-Host "##[warning]federated-model.txt not found in the root folder. Skipping rebind step."
        exit 0
      }
      # Read the content of federated-model.txt and skip the first line
      $bindings = Get-Content $federatedModelFile | Select-Object -Skip 1 | Where-Object { $_ -match "^\s*[^#]" } | ForEach-Object {
        if ($_ -match "^(.+?)\s*:\s*(.+)$") {
          [PSCustomObject]@{
            Report   = $matches[1].Trim()
            Dataset  = $matches[2].Trim()
          }
        }
      }
      # Retrieve the workspace ID from the previous step
      $workspaceId = "$(workspaceId)"
      # Retrieve the repository name
      $repoName = "$(Build.Repository.Name)"
      # Compute the repository name prefix (e.g., "PowerBI1-")
      $repoNamePrefix = "$([System.IO.Path]::GetFileNameWithoutExtension($repoName))-"
      # Retrieve the list of datasets in the workspace
      $datasetsJson = pbicli dataset list --workspace $workspaceId --output json
      $datasets = ($datasetsJson | ConvertFrom-Json) | Select-Object id, name
      # Create a dictionary for dataset name to ID mapping
      $datasetDict = @{}
      foreach ($dataset in $datasets) {
        $datasetDict[$dataset.name] = $dataset.id
      }
      # Rebind each report to its target dataset
      foreach ($binding in $bindings) {
        $reportName = $repoNamePrefix + $binding.Report
        $datasetName = $repoNamePrefix + $binding.Dataset
        if (-not $datasetDict.ContainsKey($datasetName)) {
          Write-Host "##[error]Dataset '$datasetName' not found in the workspace. Skipping rebind for report '$reportName'."
          continue
        }
        $datasetId = $datasetDict[$datasetName]
        # Debugging: Print the rebind command with proper quoting
        $rebindCommand = "pbicli report rebind --workspace $workspaceId --report `"$reportName`" --target-dataset $datasetId"
        Write-Host "##[debug]Generated Rebind Command: $rebindCommand"
        try {
          Write-Host "##[info]Rebinding report '$reportName' to dataset '$datasetName' (ID: $datasetId)"
          # Execute the rebind command
          Invoke-Expression $rebindCommand
          Write-Host "##[info]Successfully rebound report '$reportName' to dataset '$datasetName'"
        } catch {
          Write-Host "##[error]Failed to rebind report '$reportName' to dataset '$datasetName'. Error: $_"
        }
      }
    displayName: 'Rebind Reports to Datasets Based on federated-model.txt'
